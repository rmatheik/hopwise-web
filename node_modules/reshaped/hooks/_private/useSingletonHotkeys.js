import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
/**
 * Utilities
 */
const COMBINATION_DELIMETER = "+";
const pressedMap = {};
let modifiedKeys = [];
const formatHotkey = (hotkey) => {
    if (hotkey === " ")
        return hotkey;
    return hotkey.replace(/\s/g, "").toLowerCase();
};
// Normalize passed key combinations to turn them into a consistent ids
const getHotkeyId = (hotkey) => {
    return formatHotkey(hotkey).split(COMBINATION_DELIMETER).sort().join(COMBINATION_DELIMETER);
};
const getEventKey = (e) => {
    if (!e.key)
        return;
    // Having alt pressed modifies e.key value, so relying on e.code for it
    if (e.altKey && e.key !== "Alt") {
        return e.code.toLowerCase().replace(/key|digit|numpad/, "");
    }
    return e.key.toLowerCase();
};
const walkHotkeys = (hotkeys, cb) => {
    Object.keys(hotkeys).forEach((key) => {
        key.split(",").forEach((hotkey) => {
            const data = hotkeys[key];
            if (!data)
                return;
            cb(getHotkeyId(hotkey), data);
        });
    });
};
export class HotkeyStore {
    constructor() {
        this.hotkeyMap = {};
        this.getSize = () => Object.keys(this.hotkeyMap).length;
        this.bindHotkeys = (hotkeys, ref, options) => {
            walkHotkeys(hotkeys, (id, hotkeyData) => {
                if (!hotkeyData)
                    return;
                if (!this.hotkeyMap[id]) {
                    this.hotkeyMap[id] = new Set();
                }
                this.hotkeyMap[id].add({ callback: hotkeyData, ref, options });
            });
        };
        this.unbindHotkeys = (hotkeys) => {
            walkHotkeys(hotkeys, (id, hotkeyCallback) => {
                var _a, _b;
                if (!hotkeyCallback)
                    return;
                (_a = this.hotkeyMap[id]) === null || _a === void 0 ? void 0 : _a.forEach((data) => {
                    if (data.callback === hotkeyCallback) {
                        this.hotkeyMap[id].delete(data);
                    }
                });
                if (!((_b = this.hotkeyMap[id]) === null || _b === void 0 ? void 0 : _b.size)) {
                    delete this.hotkeyMap[id];
                }
            });
        };
        this.handleKeyDown = (pressedMap, e) => {
            const pressedKeys = Object.keys(pressedMap);
            if (!pressedKeys.length)
                return;
            const pressedId = getHotkeyId(pressedKeys.join(COMBINATION_DELIMETER));
            const pressedFormattedKeys = pressedId.split(COMBINATION_DELIMETER);
            const hotkeyData = this.hotkeyMap[pressedId];
            /**
             * Support for `mod` that represents both Mac and Win keyboards
             */
            const hotkeyControlModData = pressedFormattedKeys.includes("control") &&
                this.hotkeyMap[pressedId.replace("control", "mod")];
            const hotkeyMetaModData = pressedFormattedKeys.includes("meta") && this.hotkeyMap[pressedId.replace("meta", "mod")];
            [hotkeyData, hotkeyControlModData, hotkeyMetaModData].forEach((hotkeyData) => {
                if (!hotkeyData)
                    return;
                if (hotkeyData === null || hotkeyData === void 0 ? void 0 : hotkeyData.size) {
                    hotkeyData.forEach((data) => {
                        var _a;
                        if (((_a = data.ref) === null || _a === void 0 ? void 0 : _a.current) &&
                            !(e.target === data.ref.current || data.ref.current.contains(e.target))) {
                            return;
                        }
                        const resolvedEvent = pressedMap[pressedId];
                        if (data.options.preventDefault) {
                            resolvedEvent === null || resolvedEvent === void 0 ? void 0 : resolvedEvent.preventDefault();
                        }
                        data.callback(resolvedEvent);
                    });
                }
            });
        };
    }
}
const globalHotkeyStore = new HotkeyStore();
/**
 * Components / Hooks
 */
export const HotkeyContext = React.createContext({});
export const SingletonHotkeysProvider = (props) => {
    const { children } = props;
    // eslint-disable-next-line
    const [_, setTriggerCount] = React.useState(0);
    // Only handle key presses when there is at least one hook listening for hotkeys
    const [hooksCount, setHooksCount] = React.useState(0);
    const addPressedKey = React.useCallback((e) => {
        if (e.repeat || hooksCount === 0)
            return;
        const eventKey = getEventKey(e);
        if (!eventKey)
            return;
        pressedMap[eventKey] = e;
        setTriggerCount(Object.keys(pressedMap).length);
        // Key up won't trigger for other keys while Meta is pressed so we need to cache them
        // and remove on Meta keyup
        if (e.metaKey)
            modifiedKeys.push(...Object.keys(pressedMap));
        if (pressedMap.Meta)
            modifiedKeys.push(eventKey);
    }, [hooksCount]);
    const removePressedKey = React.useCallback((e) => {
        if (hooksCount === 0)
            return;
        const eventKey = getEventKey(e);
        if (!eventKey)
            return;
        delete pressedMap[eventKey];
        if (eventKey === "meta" || eventKey === "control") {
            delete pressedMap.mod;
        }
        if (eventKey === "meta") {
            modifiedKeys.forEach((key) => {
                if (!pressedMap[key])
                    return;
                delete pressedMap[key];
            });
            modifiedKeys = [];
        }
        setTriggerCount(Object.keys(pressedMap).length);
    }, [hooksCount]);
    const isPressed = (hotkey) => {
        const keys = formatHotkey(hotkey).split(COMBINATION_DELIMETER);
        if (keys.some((key) => !pressedMap[key]))
            return false;
        return true;
    };
    const addHotkeys = React.useCallback((hotkeys, ref, options = {}) => {
        setHooksCount((prev) => prev + 1);
        globalHotkeyStore.bindHotkeys(hotkeys, ref, options);
        return () => {
            setHooksCount((prev) => prev - 1);
            globalHotkeyStore.unbindHotkeys(hotkeys);
        };
    }, []);
    const handleWindowKeyDown = React.useCallback((e) => {
        // Browsers trigger keyboard event without passing e.key when you click on autocomplete
        if (!e.key)
            return;
        addPressedKey(e);
        globalHotkeyStore.handleKeyDown(pressedMap, e);
    }, [addPressedKey]);
    const handleWindowKeyUp = React.useCallback((e) => {
        if (!e.key)
            return;
        removePressedKey(e);
    }, [removePressedKey]);
    React.useEffect(() => {
        window.addEventListener("keydown", handleWindowKeyDown);
        window.addEventListener("keyup", handleWindowKeyUp);
        return () => {
            window.removeEventListener("keydown", handleWindowKeyDown);
            window.removeEventListener("keyup", handleWindowKeyUp);
        };
    }, [handleWindowKeyDown, handleWindowKeyUp]);
    return (_jsx(HotkeyContext.Provider, { value: { addHotkeys, isPressed }, children: children }));
};
const useSingletonHotkeys = () => React.useContext(HotkeyContext);
export default useSingletonHotkeys;
