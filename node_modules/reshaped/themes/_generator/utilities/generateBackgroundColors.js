"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const color_1 = require("./color");
const constants_1 = require("../constants");
const string_1 = require("../../../utilities/string");
const generateBackgroundColors = (definition, themeOptions) => {
    if (!definition.color)
        return;
    Object.keys(definition.color).forEach((tokenName) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const bgToken = (_a = definition.color) === null || _a === void 0 ? void 0 : _a[tokenName];
        const generatedForegroundName = `on${(0, string_1.capitalize)(tokenName)}`;
        const generatedRGBName = `rgb${(0, string_1.capitalize)(tokenName)}`;
        const generateOnColorsFor = [
            ...constants_1.bgWithDynamicForeground,
            ...((themeOptions === null || themeOptions === void 0 ? void 0 : themeOptions.generateOnColorsFor) || []),
        ];
        const needsDynamicForeground = generateOnColorsFor.includes(tokenName);
        const needsRGB = tokenName.startsWith("background") ||
            tokenName.startsWith("border") ||
            tokenName.endsWith("black") ||
            tokenName.endsWith("white");
        if (!bgToken)
            return;
        if (needsDynamicForeground) {
            const overrideKeys = (themeOptions === null || themeOptions === void 0 ? void 0 : themeOptions.onColorValues) && Object.keys(themeOptions === null || themeOptions === void 0 ? void 0 : themeOptions.onColorValues);
            const onColorKey = overrideKeys && overrideKeys.find((key) => tokenName.toLowerCase().includes(key));
            const onColorHexMap = {
                lightHexColor: (onColorKey && ((_c = (_b = themeOptions === null || themeOptions === void 0 ? void 0 : themeOptions.onColorValues) === null || _b === void 0 ? void 0 : _b[onColorKey]) === null || _c === void 0 ? void 0 : _c.hexLight)) ||
                    ((_e = (_d = definition === null || definition === void 0 ? void 0 : definition.color) === null || _d === void 0 ? void 0 : _d.white) === null || _e === void 0 ? void 0 : _e.hex),
                darkHexColor: (onColorKey && ((_g = (_f = themeOptions === null || themeOptions === void 0 ? void 0 : themeOptions.onColorValues) === null || _f === void 0 ? void 0 : _f[onColorKey]) === null || _g === void 0 ? void 0 : _g.hexDark)) ||
                    ((_j = (_h = definition === null || definition === void 0 ? void 0 : definition.color) === null || _h === void 0 ? void 0 : _h.black) === null || _j === void 0 ? void 0 : _j.hex),
            };
            const hex = (0, color_1.getOnColor)(Object.assign({ bgHexColor: bgToken.hex, mode: "light" }, onColorHexMap));
            const hexDark = (0, color_1.getOnColor)(Object.assign({ bgHexColor: bgToken.hexDark || bgToken.hex, mode: "dark" }, onColorHexMap));
            // eslint-disable-next-line no-param-reassign
            definition.color[generatedForegroundName] = {
                hex,
                hexDark: hex !== hexDark ? hexDark : undefined,
            };
        }
        if (needsRGB) {
            const rgb = (0, color_1.hexToRgb)(bgToken.hex);
            const rgbDark = bgToken.hexDark && (0, color_1.hexToRgb)(bgToken.hexDark);
            // eslint-disable-next-line no-param-reassign
            definition.color[generatedRGBName] = {
                hex: `${rgb.r}, ${rgb.g}, ${rgb.b}`,
                hexDark: rgbDark && `${rgbDark.r}, ${rgbDark.g}, ${rgbDark.b}`,
            };
        }
    });
};
exports.default = generateBackgroundColors;
