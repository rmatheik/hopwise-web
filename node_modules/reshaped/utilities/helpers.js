export const range = (start, end) => {
    if (start > end)
        return [];
    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
};
// from https://gist.github.com/ca0v/73a31f57b397606c9813472f7493a940
export const debounce = (cb, wait = 20) => {
    let timer;
    const callable = (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => cb(...args), wait);
    };
    return callable;
};
export function debounceHandler(handler, timeout) {
    const debounced = debounce(handler, timeout);
    return (event) => {
        if ("persist" in event)
            event.persist();
        return debounced(event);
    };
}
export const throttle = (cb, wait) => {
    let waiting = false;
    return (...args) => {
        if (!waiting) {
            cb(...args);
            waiting = true;
            setTimeout(() => {
                waiting = false;
                setTimeout(() => {
                    if (waiting)
                        return;
                    cb(...args);
                }, wait);
            }, wait);
        }
    };
};
export function throttleHandler(handler, timeout) {
    const throttled = throttle(handler, timeout);
    return (event) => {
        if ("persist" in event)
            event.persist();
        return throttled(event);
    };
}
export const classNames = (...args) => {
    return args.reduce((acc, cur) => {
        if (Array.isArray(cur)) {
            const className = classNames(...cur);
            if (!className)
                return acc;
            return `${acc} ${className}`;
        }
        if (cur)
            return `${acc} ${cur}`;
        return acc;
    }, "");
};
const applyClassName = (passedClassName, value, options) => {
    const { base, excludeValueFromClassName } = options || {};
    const className = typeof passedClassName === "string" ? passedClassName : passedClassName(value);
    if ((value === true && base) || excludeValueFromClassName)
        return className;
    // CSS should be turned on/off for non base viewport with mobile first approach
    if (value === true && !base)
        return `${className}-true`;
    if (value === false && !base)
        return `${className}-false`;
    if (value !== undefined)
        return `${className}-${value}`;
    return null;
};
export const responsiveClassNames = (s, className, value, options) => {
    if (typeof value !== "object") {
        const staticClassName = applyClassName(className, value, {
            base: true,
            excludeValueFromClassName: options === null || options === void 0 ? void 0 : options.excludeValueFromClassName,
        });
        return staticClassName ? [s[staticClassName]] : [];
    }
    return Object.keys(value).reduce((acc, viewport) => {
        const base = viewport === "s";
        const viewportClassName = applyClassName(className, value[viewport], {
            base,
            excludeValueFromClassName: options === null || options === void 0 ? void 0 : options.excludeValueFromClassName,
        });
        const suffix = base ? "" : `--${viewport}`;
        return [...acc, s[`${viewportClassName}${suffix}`]];
    }, []);
};
export const responsiveVariables = (variableName, value) => {
    if (value === undefined)
        return {};
    if (typeof value !== "object")
        return { [`${variableName}-s`]: value };
    return Object.keys(value).reduce((acc, key) => {
        const viewportValue = value[key];
        if (viewportValue === undefined)
            return acc;
        if (viewportValue === false)
            return acc;
        return Object.assign(Object.assign({}, acc), { [`${variableName}-${key}`]: viewportValue });
    }, {});
};
const isResponsive = (prop) => {
    if (prop === null)
        return false;
    return typeof prop === "object" && prop !== null && "s" in prop;
};
export const responsivePropDependency = (prop, resolver) => {
    if (!isResponsive(prop))
        return resolver(prop, "s");
    const keys = Object.keys(prop);
    return keys.reduce((acc, viewport) => {
        const viewportValue = prop[viewport];
        if (viewportValue === undefined || viewportValue === null)
            return acc;
        return Object.assign(Object.assign({}, acc), { [viewport]: resolver(viewportValue, viewport) });
    }, {});
};
const viewports = ["s", "m", "l", "xl"];
export const resolveViewportValue = (viewport, value) => {
    let result;
    if (!isResponsive(value))
        return value;
    for (let currentViewport of viewports) {
        const viewportValue = value[currentViewport];
        if (viewportValue !== undefined)
            result = viewportValue;
        if (currentViewport === viewport)
            return result;
    }
};
