"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { classNames, responsiveClassNames, responsivePropDependency } from "../../utilities/helpers.js";
import useElementId from "../../hooks/useElementId.js";
import { useFormControl } from "../FormControl/index.js";
import Icon from "../Icon/index.js";
import Aligner from "../_private/Aligner/index.js";
import s from "./TextField.module.css";
const TextFieldSlot = (props) => {
    const { slot, icon, size, affix, position } = props;
    if (!icon && !slot && !affix)
        return null;
    const attachmentClassNames = classNames(s.attachment, s[`attachment--position-${position}`]);
    const content = [
        slot && (_jsx("div", { className: s.slot, children: slot }, "slot")),
        icon && (_jsx("div", { className: s.icon, children: _jsx(Icon, { size: responsivePropDependency(size, (size) => {
                    if (size === "large")
                        return 5;
                    if (size === "xlarge")
                        return 6;
                    return 4;
                }), svg: icon }) }, "icon")),
        affix && (_jsx("div", { className: s.affix, children: affix }, "affix")),
    ].filter(Boolean);
    return (_jsx("span", { className: attachmentClassNames, children: position === "end" ? content.reverse() : content }));
};
const TextField = (props) => {
    var _a;
    const { onChange, onFocus, onBlur, name, value, defaultValue, placeholder, icon, endIcon, startSlot, endSlot, prefix, suffix, size = "medium", variant = "outline", className, attributes, } = props;
    const formControl = useFormControl();
    const id = useElementId(props.id);
    const inputId = (formControl === null || formControl === void 0 ? void 0 : formControl.attributes.id) || ((_a = props.inputAttributes) === null || _a === void 0 ? void 0 : _a.id) || id;
    const disabled = (formControl === null || formControl === void 0 ? void 0 : formControl.disabled) || props.disabled;
    const hasError = (formControl === null || formControl === void 0 ? void 0 : formControl.hasError) || props.hasError;
    const inputAttributes = Object.assign(Object.assign({}, props.inputAttributes), formControl === null || formControl === void 0 ? void 0 : formControl.attributes);
    const rootClassName = classNames(s.root, className, size && responsiveClassNames(s, "--size", size), hasError && s["--status-error"], disabled && s["--disabled"], variant && s[`--variant-${variant}`]);
    const handleChange = (event) => {
        if (!onChange)
            return;
        onChange({ name, value: event.target.value, event });
    };
    return (_jsxs("div", Object.assign({}, attributes, { "data-rs-aligner-target": true, className: rootClassName, children: [_jsx(TextFieldSlot, { position: "start", icon: icon, slot: startSlot, size: size, affix: prefix }), _jsx("input", Object.assign({}, inputAttributes, { className: s.input, disabled: disabled, name: name, placeholder: placeholder, value: value, defaultValue: defaultValue, onChange: handleChange, onFocus: onFocus || (inputAttributes === null || inputAttributes === void 0 ? void 0 : inputAttributes.onFocus), onBlur: onBlur || (inputAttributes === null || inputAttributes === void 0 ? void 0 : inputAttributes.onBlur), id: inputId })), _jsx(TextFieldSlot, { position: "end", icon: endIcon, slot: endSlot, size: size, affix: suffix })] })));
};
TextField.Aligner = Aligner;
export default TextField;
