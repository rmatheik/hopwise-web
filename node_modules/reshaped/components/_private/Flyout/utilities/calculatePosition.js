const SCREEN_OFFSET = 16;
const getRTLPosition = (position) => {
    if (position.includes("start"))
        return position.replace("start", "end");
    if (position.includes("end"))
        return position.replace("end", "start");
    return position;
};
/**
 * Get a position value which centers 2 elements vertically or horizontally
 */
const centerBySize = (originSize, targetSize) => {
    return Math.floor(originSize / 2 - targetSize / 2);
};
/**
 * Calculate styles for the current position
 */
const calculatePosition = (args) => {
    const { triggerBounds, flyoutBounds, scopeOffset, position: passedPosition, rtl, width } = args;
    let left = 0;
    let top = 0;
    let position = passedPosition;
    if (rtl)
        position = getRTLPosition(position);
    if (width === "full" || width === "trigger") {
        position = position.includes("top") ? "top" : "bottom";
    }
    switch (position) {
        case "bottom":
        case "top":
            left = centerBySize(triggerBounds.width, flyoutBounds.width) + triggerBounds.left;
            break;
        case "start":
        case "start-top":
        case "start-bottom":
            left = triggerBounds.left - triggerBounds.width;
            break;
        case "end":
        case "end-top":
        case "end-bottom":
            left = triggerBounds.right;
            break;
        case "top-start":
        case "bottom-start":
            left = triggerBounds.left;
            break;
        case "top-end":
        case "bottom-end":
            left = triggerBounds.right - flyoutBounds.width;
            break;
        default:
            break;
    }
    switch (position) {
        case "top":
        case "top-start":
        case "top-end":
            top = triggerBounds.top - flyoutBounds.height;
            break;
        case "bottom":
        case "bottom-start":
        case "bottom-end":
            top = triggerBounds.bottom;
            break;
        case "start":
        case "end":
            top = centerBySize(triggerBounds.height, flyoutBounds.height) + triggerBounds.top;
            break;
        case "start-top":
        case "end-top":
            top = triggerBounds.top;
            break;
        case "start-bottom":
        case "end-bottom":
            top = triggerBounds.bottom - triggerBounds.height;
            break;
        default:
            break;
    }
    if (top === undefined || left === undefined) {
        throw Error(`[Reshaped, flyout]: ${position} position is not valid`);
    }
    top = Math.round(top + (window.scrollY || 0) - scopeOffset.top);
    left = Math.round(left + (window.scrollX || 0) - scopeOffset.left);
    let widthStyle = Math.ceil(flyoutBounds.width);
    const height = Math.ceil(flyoutBounds.height);
    if (width === "full") {
        left = SCREEN_OFFSET;
        widthStyle = window.innerWidth - SCREEN_OFFSET * 2;
    }
    else if (width === "trigger") {
        widthStyle = triggerBounds.width;
    }
    const styles = { left, top, width: widthStyle, height };
    return { styles, position };
};
export default calculatePosition;
