import React from "react";
import useRTL from "../../../hooks/useRTL.js";
import { getClosestFlyoutTarget } from "../../../utilities/dom.js";
import calculatePosition from "./utilities/calculatePosition.js";
const topPos = ["top-start", "top", "top-end"];
const bottomPos = ["bottom-start", "bottom", "bottom-end"];
const startPos = ["start", "start-bottom", "start-top"];
const endPos = ["end", "end-bottom", "end-top"];
const order = {
    top: [...topPos, ...bottomPos, ...endPos, ...startPos],
    bottom: [...bottomPos, ...topPos, ...endPos, ...startPos],
    start: [...startPos, ...endPos, ...topPos, ...bottomPos],
    end: [...endPos, ...startPos, ...topPos, ...bottomPos],
};
/**
 * Get an order of positions to try to fit popover on the screen based on its starting position
 */
const getPositionOrder = (position) => {
    const types = ["top", "bottom", "start", "end"];
    const type = types.find((type) => position.startsWith(type)) || "bottom";
    return order[type];
};
/**
 * Check if element visually fits on the screen
 */
const fullyVisible = (bounds) => {
    const htmlEl = document.documentElement;
    const pageLeft = htmlEl.scrollLeft;
    const pageRight = pageLeft + htmlEl.clientWidth;
    const pageTop = htmlEl.scrollTop;
    const pageBottom = pageTop + htmlEl.clientHeight;
    return (bounds.left >= pageLeft &&
        bounds.left + bounds.width <= pageRight &&
        bounds.top >= pageTop &&
        bounds.top + bounds.height <= pageBottom);
};
/**
 * Order of keys here is responsible for the order of styles applied
 */
const defaultStyles = {
    left: 0,
    top: 0,
    width: "auto",
    height: "auto",
    // z-index doesn't accept strings
    zIndex: "var(--rs-z-index-flyout)",
};
const resetStyles = {
    left: 0,
    top: 0,
    position: "fixed",
    // opacity: 0,
    visibility: "hidden",
    animation: "none",
    transition: "none",
    zIndex: "var(--rs-z-index-tooltip)",
};
/**
 * Set position of the target element to fit on the screen
 */
const flyout = (triggerEl, flyoutEl, options) => {
    const { position, forcePosition, width } = options;
    const targetClone = flyoutEl.cloneNode(true);
    const triggerBounds = triggerEl.getBoundingClientRect();
    // Reset all styles applied on the previous hook execution
    targetClone.style = "";
    Object.keys(resetStyles).forEach((key) => {
        const value = resetStyles[key];
        targetClone.style[key] = value.toString();
    });
    if (width) {
        if (width === "trigger") {
            targetClone.style.width = `${triggerBounds.width}px`;
        }
        else if (width !== "full") {
            targetClone.style.width = width;
        }
    }
    document.body.appendChild(targetClone);
    const flyoutBounds = targetClone.getBoundingClientRect();
    const scrollableParent = getClosestFlyoutTarget(triggerEl);
    const scopeBounds = scrollableParent.getBoundingClientRect();
    const scopeOffset = {
        top: scopeBounds.top + document.documentElement.scrollTop - scrollableParent.scrollTop,
        left: scopeBounds.left + document.documentElement.scrollLeft - scrollableParent.scrollLeft,
    };
    let calculated = calculatePosition(Object.assign({ triggerBounds, flyoutBounds, scopeOffset }, options));
    if (!fullyVisible(calculated.styles) && !forcePosition) {
        const order = getPositionOrder(position);
        const mobileOrder = order.filter((position) => position === "top" || position === "bottom");
        const test = (testOrder, extraOptions = {}) => {
            const { fullWidth } = extraOptions;
            testOrder.some((currentPosition) => {
                const calculateOptions = Object.assign(Object.assign({}, options), { width: fullWidth ? "full" : options.width, position: currentPosition });
                const tested = calculatePosition(Object.assign({ triggerBounds,
                    flyoutBounds,
                    scopeOffset }, calculateOptions));
                if (fullyVisible(tested.styles)) {
                    calculated = tested;
                    return true;
                }
                return false;
            });
        };
        test(order);
        if (!fullyVisible(calculated.styles)) {
            test(mobileOrder, { fullWidth: true });
        }
    }
    targetClone.parentNode.removeChild(targetClone);
    return calculated;
};
const flyoutReducer = (state, action) => {
    switch (action.type) {
        case "render":
            if (state.status !== "idle")
                return state;
            // Disable events before it's positioned to avoid mouseleave getting triggered
            return Object.assign(Object.assign({}, state), { status: "rendered", styles: Object.assign({ pointerEvents: "none" }, resetStyles) });
        case "position":
            if (state.status !== "rendered")
                return state;
            return Object.assign(Object.assign({}, state), { status: "positioned", position: action.payload.position, styles: Object.assign(Object.assign({}, defaultStyles), action.payload.styles) });
        case "show":
            if (state.status !== "positioned")
                return state;
            return Object.assign(Object.assign({}, state), { status: "visible" });
        case "hide":
            if (state.status !== "visible")
                return state;
            return Object.assign(Object.assign({}, state), { status: "hidden" });
        case "remove":
            if (state.status !== "hidden" && state.status !== "visible")
                return state;
            return Object.assign(Object.assign({}, state), { status: "idle", styles: resetStyles });
        default:
            throw new Error("Invalid reducer type");
    }
};
const useFlyout = (originRef, targetRef, options) => {
    const { position: defaultPosition = "bottom", forcePosition, width } = options;
    const [isRTL] = useRTL();
    const [state, dispatch] = React.useReducer(flyoutReducer, {
        position: defaultPosition,
        styles: defaultStyles,
        status: "idle",
    });
    const render = React.useCallback(() => {
        dispatch({ type: "render" });
    }, []);
    const show = React.useCallback(() => {
        dispatch({ type: "show" });
    }, []);
    const hide = React.useCallback(() => {
        dispatch({ type: "hide" });
    }, []);
    const remove = React.useCallback(() => {
        dispatch({ type: "remove" });
    }, []);
    const updatePosition = React.useCallback(() => {
        if (!originRef.current || !targetRef.current)
            return;
        const nextFlyoutData = flyout(originRef.current, targetRef.current, {
            width,
            position: defaultPosition,
            forcePosition,
            rtl: isRTL,
        });
        dispatch({ type: "position", payload: nextFlyoutData });
    }, [originRef, targetRef, defaultPosition, isRTL, forcePosition, width]);
    React.useEffect(() => {
        if (state.status === "rendered")
            updatePosition();
    }, [state.status, updatePosition]);
    return React.useMemo(() => ({
        position: state.position,
        styles: state.styles,
        status: state.status,
        updatePosition,
        render,
        hide,
        remove,
        show,
    }), [render, updatePosition, hide, remove, show, state.position, state.styles, state.status]);
};
export default useFlyout;
