"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import { classNames } from "../../utilities/helpers.js";
import HiddenInput from "../_private/HiddenInput/index.js";
import Actionable from "../Actionable/index.js";
import Icon from "../Icon/index.js";
import Text from "../Text/index.js";
import { useTabs } from "./TabsContext.js";
import s from "./Tabs.module.css";
const TabsItem = (props, ref) => {
    const { value, children, icon, href, attributes } = props;
    const { onChange, panelId, name, size, value: tabsValue, selection, elActiveRef, elPrevActiveRef, elScrollableRef, } = useTabs(value);
    const itemRef = React.useRef(null);
    const active = tabsValue === value;
    const visuallySelected = active && selection.status === "idle";
    const itemClassNames = classNames(s.item, visuallySelected && s["--item-active"]);
    const isFormControl = !!name;
    const tabAttributes = {
        role: "tab",
        tabIndex: active ? 0 : -1,
        "aria-selected": active,
    };
    const updateRefs = React.useCallback(() => {
        if (!("current" in itemRef)) {
            throw new Error("Reshaped, Tabs: TabItem is expecting an object ref format but received a function ref");
        }
        elPrevActiveRef.current = elActiveRef.current;
        elActiveRef.current = itemRef.current;
    }, [elActiveRef, elPrevActiveRef]);
    const handleChange = () => {
        var _a, _b, _c;
        if (href && !onChange)
            return;
        const listEl = elScrollableRef.current;
        const currentListItem = (_a = itemRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
        const prevListItem = (_b = elActiveRef.current) === null || _b === void 0 ? void 0 : _b.parentElement;
        // Updating refs after saving the elements
        updateRefs();
        if (onChange)
            onChange({ value, name });
        if (!listEl || !currentListItem || !prevListItem || listEl.scrollWidth === listEl.clientWidth) {
            return;
        }
        const navigatingBack = currentListItem.offsetLeft < prevListItem.offsetLeft;
        const threshold = (currentListItem.offsetLeft - listEl.scrollLeft) / listEl.clientWidth;
        // Only scroll if the item is close to getting clipped
        // Back navigation threshold is 0.3 since its calculated based on offsetLeft
        const shouldScroll = navigatingBack ? threshold < 0.3 : threshold > 0.5;
        if (!shouldScroll)
            return;
        (_c = itemRef.current) === null || _c === void 0 ? void 0 : _c.scrollIntoView({ behavior: "smooth", block: "center", inline: "center" });
    };
    React.useEffect(() => {
        if (!active)
            return;
        updateRefs();
    }, [active, updateRefs]);
    return (_jsx("div", Object.assign({}, attributes, { className: itemClassNames, ref: itemRef, role: "presentation", children: _jsxs(Actionable, { ref: ref, href: href, insetFocus: true, onClick: !name ? handleChange : undefined, className: s.button, as: name ? "label" : undefined, attributes: Object.assign(Object.assign({}, (!isFormControl && tabAttributes)), { "aria-controls": panelId }), children: [name && (_jsx(HiddenInput, { type: "radio", name: name, value: value, checked: visuallySelected, onChange: handleChange, className: s.radio })), _jsxs("span", { className: s.buttonContent, children: [icon && _jsx(Icon, { svg: icon, className: s.icon, size: 4 }), children && (_jsx(Text, { variant: size === "large" ? "body-2" : "body-3", weight: "medium", children: children }))] })] }) })));
};
export default React.forwardRef(TabsItem);
