"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import { classNames, throttle } from "../../utilities/helpers.js";
import useRTL from "../../hooks/useRTL.js";
import { focusNextElement, focusPreviousElement, focusFirstElement, focusLastElement, } from "../../utilities/a11y/focus.js";
import useIsomorphicLayoutEffect from "../../hooks/useIsomorphicLayoutEffect.js";
import useHotkeys from "../../hooks/useHotkeys.js";
import Button from "../Button/index.js";
import IconChevronRight from "../../icons/ChevronRight.js";
import IconChevronLeft from "../../icons/ChevronLeft.js";
import TabsItem from "./TabsItem.js";
import { useTabs } from "./TabsContext.js";
import s from "./Tabs.module.css";
const findParentItem = (el, rootEl) => {
    if (el === rootEl || !el)
        return null;
    if (el.classList.contains(s.listItem))
        return el;
    return findParentItem(el.parentElement, rootEl);
};
const TabsList = (props) => {
    const { children, className, attributes } = props;
    const { value, setDefaultValue, itemWidth, variant, name, direction, size, selection, setSelection, elActiveRef, elPrevActiveRef, elScrollableRef, } = useTabs();
    const [rtl] = useRTL();
    const [fadeSide, setFadeSide] = React.useState(null);
    const rootClassNames = classNames(s.root, size && s[`--size-${size}`], direction && s[`--direction-${direction}`], itemWidth && s[`--item-width-${itemWidth}`], variant && s[`--variant-${variant}`], (fadeSide === "start" || fadeSide === "both") && s["--fade-start"], (fadeSide === "end" || fadeSide === "both") && s["--fade-end"], className);
    const selectorClassNames = classNames(s.selector, selection.status === "idle" && s["--selector-hidden"], selection.status === "animated" && s["--selector-animated"]);
    const handleNextClick = () => {
        elScrollableRef.current.scrollBy({
            // Using ceil here since during the second navigation half of the value may be
            // smaller than during the first navigation because of the odd numbers
            left: Math.ceil(elScrollableRef.current.clientWidth / 2) * (rtl ? -1 : 1),
            behavior: "smooth",
        });
    };
    const handlePrevClick = () => {
        elScrollableRef.current.scrollBy({
            left: Math.ceil(elScrollableRef.current.clientWidth / 2) * (rtl ? 1 : -1),
            behavior: "smooth",
        });
    };
    const handleTransitionEnd = () => {
        setSelection((selectionStyle) => (Object.assign(Object.assign({}, selectionStyle), { status: "idle" })));
    };
    const getElementSelectionStyle = React.useCallback((el) => {
        if (!elScrollableRef.current)
            return null;
        const itemEl = findParentItem(el, elScrollableRef.current);
        if (!itemEl)
            return null;
        return {
            scaleX: itemEl.clientWidth,
            scaleY: itemEl.clientHeight,
            top: itemEl.offsetTop,
            left: itemEl.offsetLeft,
        };
    }, [elScrollableRef]);
    const { ref: hotkeysRef } = useHotkeys({
        "ArrowLeft, ArrowUp": (e) => {
            if (name)
                return;
            e.preventDefault();
            focusPreviousElement(elScrollableRef.current);
        },
        "ArrowRight, ArrowDown": (e) => {
            if (name)
                return;
            e.preventDefault();
            focusNextElement(elScrollableRef.current);
        },
        Home: (e) => {
            if (name)
                return;
            e.preventDefault();
            focusFirstElement(elScrollableRef.current);
        },
        End: (e) => {
            if (name)
                return;
            e.preventDefault();
            focusLastElement(elScrollableRef.current);
        },
    });
    useIsomorphicLayoutEffect(() => {
        if (value)
            return;
        const firstItem = React.Children.toArray(children)[0];
        if (!firstItem || firstItem.type !== TabsItem)
            return;
        setDefaultValue(firstItem.props.value);
    }, [value]);
    useIsomorphicLayoutEffect(() => {
        // Do not update selection on mount, until we receive new activeId
        if (!elPrevActiveRef.current || elPrevActiveRef.current === elActiveRef.current)
            return;
        const selectionStyle = getElementSelectionStyle(elPrevActiveRef.current);
        if (!selectionStyle)
            return;
        setSelection(Object.assign(Object.assign({}, selectionStyle), { status: "prepared" }));
    }, [value, getElementSelectionStyle]);
    useIsomorphicLayoutEffect(() => {
        if (selection.status !== "prepared" || !elActiveRef.current)
            return;
        const selectionStyle = getElementSelectionStyle(elActiveRef.current);
        if (!selectionStyle)
            return;
        setSelection(Object.assign(Object.assign({}, selectionStyle), { status: "animated" }));
    }, [selection]);
    useIsomorphicLayoutEffect(() => {
        const elScrollable = elScrollableRef.current;
        if (!elScrollable || direction === "column")
            return;
        const updateArrowNav = () => {
            const isScrollable = elScrollable.clientWidth < elScrollable.scrollWidth;
            if (!isScrollable)
                setFadeSide(null);
            // scrollLeft in RTL starts from 1 instead of 0, so we compare values using this delta
            const scrollLeft = elScrollable.scrollLeft * (rtl ? -1 : 1);
            const cutOffStart = scrollLeft > 1;
            const cutOffEnd = scrollLeft + elScrollable.clientWidth < elScrollable.scrollWidth - 1;
            if (cutOffEnd && cutOffStart)
                return setFadeSide("both");
            if (cutOffStart)
                return setFadeSide("start");
            if (cutOffEnd)
                return setFadeSide("end");
        };
        const debouncedUpdateArrowNav = throttle(updateArrowNav, 16);
        // Use RaF when scroll to have scrollWidth calculated correctly on the first effect
        // For example: And edge case inside the complex flexbox layout
        requestAnimationFrame(() => {
            updateArrowNav();
        });
        window.addEventListener("resize", debouncedUpdateArrowNav);
        elScrollable.addEventListener("scroll", debouncedUpdateArrowNav);
        return () => {
            window.removeEventListener("resize", debouncedUpdateArrowNav);
            elScrollable.removeEventListener("scroll", debouncedUpdateArrowNav);
        };
    }, [rtl]);
    return (_jsxs("div", Object.assign({}, attributes, { className: rootClassNames, children: [_jsx("div", { className: s.inner, ref: elScrollableRef, children: _jsxs("div", { className: s.list, role: "tablist", ref: hotkeysRef, children: [React.Children.map(children, (child, index) => {
                            if (!child)
                                return null;
                            return (_jsx("div", { className: s.listItem, children: child }, child.props.value || child.key || index));
                        }), _jsx("div", { onTransitionEnd: handleTransitionEnd, className: selectorClassNames, style: {
                                "--rs-tab-selection-x": selection.left,
                                "--rs-tab-selection-y": selection.top,
                                "--rs-tab-selection-scale-x": selection.scaleX,
                                "--rs-tab-selection-scale-y": selection.scaleY,
                            } })] }) }), (fadeSide === "start" || fadeSide === "both") && (_jsx("span", { className: s.prev, children: _jsx(Button, { onClick: handlePrevClick, size: "small", icon: IconChevronLeft, rounded: true, attributes: { "aria-hidden": true, tabIndex: -1 } }) })), (fadeSide === "end" || fadeSide === "both") && (_jsx("span", { className: s.next, children: _jsx(Button, { onClick: handleNextClick, size: "small", icon: IconChevronRight, rounded: true, attributes: { "aria-hidden": true, tabIndex: -1 } }) }))] })));
};
export default TabsList;
