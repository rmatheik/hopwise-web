"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import { classNames } from "../../utilities/helpers.js";
import { enableUserSelect, disableUserSelect } from "../../utilities/dom.js";
import useRTL from "../../hooks/useRTL.js";
import useElementId from "../../hooks/useElementId.js";
import { useFormControl } from "../FormControl/index.js";
import SliderThumb from "./SliderThumb.js";
import { applyStepToValue } from "./Slider.utilities.js";
import s from "./Slider.module.css";
const THUMB_SIZE = 16;
const getDragX = (event) => {
    if (event instanceof MouseEvent)
        return event.pageX || event.screenX;
    return event.changedTouches[0].pageX;
};
const SliderControlled = (props) => {
    var _a;
    const { name, range, max, min, step = 1, onChange, onChangeCommit, renderValue, className, attributes, } = props;
    const minValue = range && props.minValue !== undefined ? applyStepToValue(props.minValue, step) : undefined;
    const maxValue = applyStepToValue(range ? props.maxValue : props.value, step);
    const barRef = React.useRef(null);
    const minRef = React.useRef(null);
    const maxRef = React.useRef(null);
    const minTooltipRef = React.useRef(null);
    const maxTooltipRef = React.useRef(null);
    const [draggingId, setDraggingId] = React.useState(null);
    const [rtl] = useRTL();
    const formControl = useFormControl();
    const id = useElementId();
    const inputId = ((_a = formControl === null || formControl === void 0 ? void 0 : formControl.attributes) === null || _a === void 0 ? void 0 : _a.id) || id;
    const minId = `${inputId}-min`;
    const maxId = `${inputId}-max`;
    const disabled = (formControl === null || formControl === void 0 ? void 0 : formControl.disabled) || props.disabled;
    const rootClassNames = classNames(s.root, disabled && s["--disabled"], className);
    const getPositionValue = React.useCallback((x) => {
        if (!barRef.current)
            return;
        const barWidth = barRef.current.clientWidth;
        // Move by half thumb size since it's a reserved space
        const barX = barRef.current.getBoundingClientRect().left + THUMB_SIZE / 2;
        const positionX = x - barX;
        const thumbsAreaWidth = barWidth - THUMB_SIZE;
        let percentage = positionX / thumbsAreaWidth;
        if (rtl)
            percentage = 1 - percentage;
        let value = (max - min) * percentage + min;
        value = Math.max(min, Math.min(max, value));
        return applyStepToValue(value, step);
    }, [max, min, rtl, step]);
    const getPercentPosition = (value) => {
        const ratio = (value - min) / (max - min);
        return ratio * 100;
    };
    const positionTooltip = React.useCallback((draggingId) => {
        var _a, _b, _c;
        const draggingRef = draggingId === minId ? minTooltipRef : maxTooltipRef;
        const thumbRef = draggingId === minId ? minRef : maxRef;
        let nextTooltipOffset = 0;
        const barRect = (_a = barRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        const draggingRect = (_b = draggingRef.current) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
        const thumbRect = (_c = thumbRef.current) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect();
        const barLeftSide = barRect === null || barRect === void 0 ? void 0 : barRect.left;
        const barRightSide = barLeftSide && barLeftSide + (barRect === null || barRect === void 0 ? void 0 : barRect.width);
        const tooltipLeftSide = thumbRect && draggingRect && thumbRect.left - draggingRect.width / 2;
        const tooltipRightSide = thumbRect && draggingRect && thumbRect.left + draggingRect.width / 2;
        // Crosses the left slider boundary
        if (tooltipLeftSide && barLeftSide && tooltipLeftSide < barLeftSide - 8) {
            nextTooltipOffset = draggingRect.width / 2 - 8;
        }
        // Crosses the right slider boundary
        if (tooltipRightSide && barRightSide && tooltipRightSide > barRightSide) {
            nextTooltipOffset = -(draggingRect.width / 2 - 8);
        }
        const tooltipEl = draggingRef.current;
        if (tooltipEl) {
            tooltipEl.style.setProperty("--rs-slider-tooltip-offset", `${nextTooltipOffset || 0}px`);
        }
    }, [minId]);
    const handleMinChange = React.useCallback((value, options) => {
        if (!range)
            return;
        const method = (options === null || options === void 0 ? void 0 : options.commit) ? onChangeCommit : onChange;
        method === null || method === void 0 ? void 0 : method({ minValue: value, maxValue, name });
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [maxValue, name, range]);
    const handleMaxChange = React.useCallback((value, options) => {
        if (range) {
            const method = (options === null || options === void 0 ? void 0 : options.commit) ? onChangeCommit : onChange;
            method === null || method === void 0 ? void 0 : method({ minValue: minValue, maxValue: value, name });
            return;
        }
        const method = (options === null || options === void 0 ? void 0 : options.commit) ? onChangeCommit : onChange;
        method === null || method === void 0 ? void 0 : method({ value, name });
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [minValue, name, range]);
    const handleMouseDown = ({ nativeEvent }) => {
        if (disabled)
            return;
        let minDistance;
        let closestId;
        const x = getDragX(nativeEvent);
        const nextValue = getPositionValue(x);
        const thumbs = [
            { ref: minRef, id: minId },
            { ref: maxRef, id: maxId },
        ];
        thumbs.forEach((item) => {
            if (!item.ref.current)
                return;
            const el = item.ref.current;
            const distance = Math.abs(el.getBoundingClientRect().left - x);
            if (minDistance === undefined || distance <= minDistance) {
                minDistance = distance;
                closestId = item.id;
            }
        });
        if (!closestId || nextValue === undefined)
            return;
        if (closestId === minId)
            handleMinChange(nextValue);
        if (closestId === maxId)
            handleMaxChange(nextValue);
        disableUserSelect();
        setDraggingId(closestId);
    };
    const handleMinDragStart = () => {
        if (disabled)
            return;
        setDraggingId(minId);
    };
    const handleMaxDragStart = () => {
        if (disabled)
            return;
        setDraggingId(maxId);
    };
    const handleDragStop = React.useCallback(() => {
        if (draggingId === minId && minValue !== undefined) {
            handleMinChange(minValue, { commit: true });
        }
        if (draggingId === maxId) {
            handleMaxChange(maxValue, { commit: true });
        }
        enableUserSelect();
        setDraggingId(null);
    }, [minValue, maxValue, handleMinChange, handleMaxChange, draggingId, minId, maxId]);
    const handleDrag = React.useCallback((e) => {
        if (!draggingId)
            return;
        const x = getDragX(e);
        const nextValue = getPositionValue(x);
        if (nextValue === undefined)
            return;
        // Switch to another id if thumbs overlap
        let nextDraggingId = draggingId;
        if (draggingId === minId && nextValue > maxValue)
            nextDraggingId = maxId;
        if (draggingId === maxId && minValue && nextValue < minValue)
            nextDraggingId = minId;
        if (nextDraggingId === minId)
            handleMinChange(nextValue);
        if (nextDraggingId === maxId)
            handleMaxChange(nextValue);
        if (draggingId !== nextDraggingId)
            setDraggingId(nextDraggingId);
    }, [
        draggingId,
        minValue,
        maxValue,
        getPositionValue,
        handleMaxChange,
        handleMinChange,
        maxId,
        minId,
    ]);
    React.useEffect(() => {
        positionTooltip(minId);
        positionTooltip(maxId);
    }, [positionTooltip, minId, maxId]);
    React.useEffect(() => {
        positionTooltip(minId);
        positionTooltip(maxId);
    }, [minId, maxId, minValue, maxValue, positionTooltip]);
    React.useEffect(() => {
        window.addEventListener("mouseup", handleDragStop);
        window.addEventListener("touchend", handleDragStop);
        window.addEventListener("mousemove", handleDrag);
        window.addEventListener("touchmove", handleDrag);
        return () => {
            window.removeEventListener("mouseup", handleDragStop);
            window.removeEventListener("touchend", handleDragStop);
            window.removeEventListener("mousemove", handleDrag);
            window.removeEventListener("touchmove", handleDrag);
        };
    }, [handleDragStop, handleDrag]);
    const minPercentPosition = minValue && getPercentPosition(minValue);
    const maxPercentPosition = getPercentPosition(maxValue);
    return (
    // mouse/touch events only needed for non-keyboard use
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    _jsxs("div", Object.assign({}, attributes, { className: rootClassNames, onMouseDown: handleMouseDown, onTouchStart: handleMouseDown, children: [_jsx("div", { className: s.bar, ref: barRef, children: _jsx("div", { className: s.selection, style: {
                        insetInlineStart: `${minPercentPosition || 0}%`,
                        width: `${maxPercentPosition - (minPercentPosition || 0)}%`,
                    } }) }), _jsxs("div", { className: s.thumbs, children: [minValue !== undefined && minPercentPosition !== undefined && (_jsx(SliderThumb, { id: minId, active: minId === draggingId, name: name, disabled: disabled, onChange: handleMinChange, value: minValue, onDragStart: handleMinDragStart, position: minPercentPosition, max: max, min: min, ref: minRef, tooltipRef: minTooltipRef, renderValue: renderValue, step: step })), _jsx(SliderThumb, { id: maxId, active: maxId === draggingId, name: name, disabled: disabled, onChange: handleMaxChange, value: maxValue, onDragStart: handleMaxDragStart, position: maxPercentPosition, max: max, min: min, ref: maxRef, tooltipRef: maxTooltipRef, renderValue: renderValue, step: step })] })] })));
};
export default SliderControlled;
