"use client";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import ToastContext from "./Toast.context.js";
import ToastRegion from "./ToastRegion.js";
import useToast from "./useToast.js";
import { positions, defaultContextData } from "./Toast.constants.js";
let counter = 0;
const generateId = () => `__rs-toast-${counter++}`;
const toastReducer = (state, action) => {
    let nextState;
    switch (action.type) {
        case "add":
            const _a = action.payload.toastProps || {}, { position = "bottom-end" } = _a, toastProps = __rest(_a, ["position"]);
            return Object.assign(Object.assign({}, state), { [position]: [...state[position], { id: action.payload.id, toastProps, status: "entering" }] });
        case "show":
            const { id: showId } = action.payload;
            nextState = Object.assign({}, state);
            positions.forEach((position) => {
                nextState[position] = nextState[position].map((item) => {
                    if (item.status !== "entering")
                        return item;
                    return item.id === showId ? Object.assign(Object.assign({}, item), { status: "entered" }) : item;
                });
            });
            return nextState;
        case "hide":
            const { id: hideId } = action.payload;
            nextState = Object.assign({}, state);
            positions.forEach((position) => {
                nextState[position] = nextState[position].map((item) => item.id === hideId ? Object.assign(Object.assign({}, item), { status: "exiting" }) : item);
            });
            return nextState;
        case "remove":
            const { id: removeId } = action.payload;
            nextState = Object.assign({}, state);
            positions.forEach((position) => {
                nextState[position] = nextState[position].filter((item) => item.id !== removeId);
            });
            return nextState;
    }
};
const ToastProvider = (props) => {
    const { children, options } = props;
    const toast = useToast();
    const id = React.useId();
    const [data, dispatch] = React.useReducer(toastReducer, defaultContextData.queues);
    const add = React.useCallback((toastProps) => {
        const id = generateId();
        dispatch({ type: "add", payload: { toastProps, id } });
        return id;
    }, []);
    const show = React.useCallback((id) => {
        dispatch({ type: "show", payload: { id } });
    }, []);
    const hide = React.useCallback((id) => {
        dispatch({ type: "hide", payload: { id } });
    }, []);
    const remove = React.useCallback((id) => {
        dispatch({ type: "remove", payload: { id } });
    }, []);
    const value = React.useMemo(() => ({
        queues: data,
        id,
        add,
        show,
        hide,
        remove,
        inspecting: false,
        options,
    }), [data, show, hide, add, remove, id, options]);
    return (_jsxs(ToastContext.Provider, { value: value, children: [children, positions.map((position) => (_jsx(ToastRegion, { position: position, nested: !!toast.id }, position)))] }));
};
export default ToastProvider;
