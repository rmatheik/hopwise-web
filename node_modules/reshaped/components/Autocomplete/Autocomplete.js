"use client";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import TextField from "../TextField/index.js";
import DropdownMenu from "../DropdownMenu/index.js";
import useHotkeys from "../../hooks/useHotkeys.js";
import { getActiveElement } from "../../utilities/a11y/focus.js";
import * as keys from "../../constants/keys.js";
const AutocompleteContext = React.createContext({});
const Autocomplete = (props) => {
    const { children, onChange, onItemSelect, name } = props, textFieldProps = __rest(props, ["children", "onChange", "onItemSelect", "name"]);
    const inputRef = React.useRef(null);
    const [active, setActive] = React.useState(false);
    // Prevent dropdown from opening on selecting an item
    const [locked, setLocked] = React.useState(false);
    const hasChildren = !!React.Children.toArray(children).filter(Boolean).length;
    const handleOpen = React.useCallback(() => setActive(true), []);
    const handleClose = () => setActive(false);
    useHotkeys({
        [`${keys.UP},${keys.DOWN}`]: () => handleOpen(),
        [keys.ENTER]: () => {
            const el = getActiveElement();
            el === null || el === void 0 ? void 0 : el.click();
        },
    }, [handleOpen], { ref: inputRef, preventDefault: true });
    const handleChange = (args) => {
        onChange === null || onChange === void 0 ? void 0 : onChange(args);
        setLocked(false);
        handleOpen();
    };
    const handleItemClick = (args) => {
        onChange === null || onChange === void 0 ? void 0 : onChange({ value: args.value, name });
        onItemSelect === null || onItemSelect === void 0 ? void 0 : onItemSelect({ value: args.value });
        setLocked(true);
    };
    const handleFocus = (e) => {
        var _a;
        requestAnimationFrame(() => {
            if (!locked)
                return;
            setActive(false);
            setLocked(false);
        });
        (_a = textFieldProps.onFocus) === null || _a === void 0 ? void 0 : _a.call(textFieldProps, e);
    };
    return (_jsx(AutocompleteContext.Provider, { value: { onItemClick: handleItemClick }, children: _jsxs(DropdownMenu, { position: "bottom", width: "trigger", triggerType: "focus", trapFocusMode: "selection-menu", active: !locked && hasChildren && active, onClose: handleClose, onOpen: handleOpen, disableHideAnimation: true, children: [_jsx(DropdownMenu.Trigger, { children: (_a) => {
                        var { ref } = _a, attributes = __rest(_a, ["ref"]);
                        return (_jsx(TextField, Object.assign({}, textFieldProps, { name: name, onChange: handleChange, 
                            // Ignoring the type check since TS can't infer the correct html element type
                            attributes: Object.assign(Object.assign({}, textFieldProps.attributes), { ref }), inputAttributes: Object.assign(Object.assign({}, textFieldProps.inputAttributes), { onFocus: (e) => {
                                    var _a;
                                    (_a = attributes.onFocus) === null || _a === void 0 ? void 0 : _a.call(attributes);
                                    handleFocus(e);
                                }, ref: inputRef, role: "combobox" }) })));
                    } }), _jsx(DropdownMenu.Content, { children: children })] }) }));
};
const AutocompleteItem = (props) => {
    const { value, onClick } = props, menuItemProps = __rest(props, ["value", "onClick"]);
    const { onItemClick } = React.useContext(AutocompleteContext);
    const handleClick = (e) => {
        onClick === null || onClick === void 0 ? void 0 : onClick(e);
        onItemClick({ value });
    };
    return (_jsx(DropdownMenu.Item, Object.assign({}, menuItemProps, { attributes: Object.assign(Object.assign({}, menuItemProps.attributes), { role: "option" }), onClick: handleClick })));
};
Autocomplete.Item = AutocompleteItem;
export default Autocomplete;
