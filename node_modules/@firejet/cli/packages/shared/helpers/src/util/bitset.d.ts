declare const bitsetTag: unique symbol;
export type BitSetVal<T> = T extends BitSet<infer R> ? BitSetVal<R> : number & {
    readonly [bitsetTag]: T;
};
export type BitSet<T extends string> = {
    [key in T]: BitSetVal<T>;
} & {
    None: BitSetVal<T>;
    All: BitSetVal<T>;
    overlaps(a: BitSetVal<T>, b: BitSetVal<T>): boolean;
    contains(val: BitSetVal<T>, searchVal: BitSetVal<T>): boolean;
    add(a: BitSetVal<T>, b: BitSetVal<T>): BitSetVal<T>;
    sub(val: BitSetVal<T>, toSubtract: BitSetVal<T>): BitSetVal<T>;
    constrain(val: BitSetVal<T>, constrainBy: BitSetVal<T>): BitSetVal<T>;
    toContainer(val: BitSetVal<T>): BitSetContainer<BitSet<T>>;
    toString(val: BitSetVal<T>): string;
};
export declare function createBitSet<V extends string>(values: V[]): BitSet<V>;
export declare function createBitSet<V extends string, A extends string>(values: V[], auxillary: Record<A, NoInfer<V>[]>): BitSet<V | A>;
export declare class BitSetContainer<T extends BitSet<string>> {
    private bitset;
    value: BitSetVal<T>;
    constructor(bitset: T, value: BitSetVal<T>);
    overlaps(val: BitSetVal<T>): boolean;
    contains(searchVal: BitSetVal<T>): boolean;
    add(other: BitSetVal<T>): void;
    sub(other: BitSetVal<T>): void;
    constrain(constrainBy: BitSetVal<T>): boolean;
    toString(): string;
}
export {};
