import { Rectangle } from '../posMeta';
import { TailwindConfig } from '../tailwind-config';
import { Expand } from '../util';
import { MinLayout, UserCompiledCodebaseGroups, UserComponentWithImage } from '../user-component';
import { CustomSceneNode, CustomStyledTextSegment } from './CustomSceneNode';
import { CodeExpression, Literal, NamedFunctionDeclaration, TSSourceCode } from './code';
import { ConversionConfig } from './conversion-config';
import { LayoutStyles, PseudoSelector } from '../styles';
import { FJ } from '../cli';
import { MinSharedMeta } from '../html-to-figma';
import { MatchContext, MatchScore } from './matchContext';
export interface Folder {
    name: string;
    files: File[];
    folders: Folder[];
}
export interface File {
    name: string;
    extension: string;
    content: string;
}
export interface FireJetCodePart {
    type: 'code';
    code: string;
}
export interface NamesMixin {
    /**Name in PascalCase */
    namePscl: string;
    /**Name in kebab-case */
    nameKbb: string;
    /**Name in camelCase */
    nameCml: string;
}
export interface CodeMeta {
    config: ConversionConfig;
    components: ComponentMeta[];
    globalCSS: string;
    tailwindLayers: Partial<Record<'base' | 'components' | 'utilities', string>>;
    additionalMetaData: AdditionalMetaData;
}
export interface PossibleMatch {
    layoutName: string;
    absBox: Rectangle;
    zIndex: number;
    matches: {
        componentId: string;
        componentName: string;
        context: MatchContext;
        score: MatchScore;
    }[];
}
export interface AdditionalMetaData {
    mainComponentWidth: number;
    mainComponentHeight: number;
    allExternalDeps: ExternalDependency[];
    tailwindConfig?: TailwindConfig;
    /**A path to the image in supabase of the original design */
    targetImagePaths?: string[];
    /**Signed urls of the original design - will only be available for a limited time */
    targetImageUrls?: string[];
    assetIdToName?: Record<string, string>;
    userComponents?: UserComponentWithImage[];
    userCodeBaseGroups?: UserCompiledCodebaseGroups[];
    minLayouts?: MinLayout[];
    possibleMatches?: PossibleMatch[];
}
export type ExternalScriptMeta = ExternalFontScriptMeta;
export interface ExternalFontScriptMeta {
    type: 'font';
    path: string;
}
export interface StateMeta {
    name: string;
    initialValue: CodeExpression;
}
/** This is the prop name for the main slot/component children */
export declare const MAIN_SLOT_PROP_NAME = "##slot##";
export interface ComponentMeta extends NamesMixin {
    dependencies: DependencyMeta[];
    props: PropMeta[];
    states: StateMeta[];
    functions: NamedFunctionDeclaration[];
    layout: LayoutMeta;
    path: string;
    cssDeclarations?: {
        all: AllStyles;
        nested: NestedStyles;
    };
    figmaId?: string;
    /**An image in buffer format of the original design */
    targetImage?: Buffer;
    /**Check if children should be merged into a single component*/
    isComponentSet?: boolean;
    /**Metadata for merging at different breakpoints */
    originalWidth?: number;
    componentProperties?: CustomSceneNode['componentProperties'];
    route?: string;
}
interface PropMetaBase {
    name: string;
    defaultValue?: CodeExpression;
    meta?: Partial<{
        figmaPropName: string;
        figmaVariantOptions: string[];
        fjPropType: FJ.Any['type'];
    }>;
}
export type PropMetaInbuilt = Expand<PropMetaBase & {
    type: Literal['type'];
}>;
export type PropMetaElement = Expand<PropMetaBase & {
    type: 'element';
}>;
export type PropMetaLiteral = Expand<PropMetaBase & {
    /**Literal means that it is literally type X or type Y e.g. "TYPE_1" | "TYPE_2" */
    type: 'literal';
    literalTypes: string[];
}>;
export type PropMeta = PropMetaInbuilt | PropMetaLiteral | PropMetaElement;
export type LayoutMeta = LayoutElementMeta | LayoutStaticMeta;
type SharedLayoutFurtherMeta = Partial<{
    /**the order of the layout in the original component, useful for reording at different breakpoints
     * There are two numbers, start and end because after extra nesting because of grouping the leaves the start and end may change
     */
    originalOrder: {
        start: number;
        end: number;
    };
    absoluteBoundingBox: Rectangle;
    minSharedMeta: MinSharedMeta;
    dependencyRefs?: DependencyMeta[];
}>;
export interface LayoutElementMeta extends NamesMixin {
    type: 'element';
    condition?: TSSourceCode;
    semanticTag: string;
    classes: string[];
    attrs: Partial<{
        [nameCml: string]: LayoutAttr;
    }>;
    styles: LayoutStyles;
    pseudoElementStyles: {
        [pseudoElement in PseudoSelector]?: LayoutPseudoElement;
    };
    nestedStyles: Partial<{
        [atRuleName: string]: LayoutNested;
    }>;
    conditionalClasses: Partial<{
        [condition: TSSourceCode]: ConditionalClass;
    }>;
    conditionalAttrs: Partial<{
        [condition: TSSourceCode]: ConditionalAttr;
    }>;
    conditionalStyles: Partial<{
        [condition: TSSourceCode]: ConditionalStyle;
    }>;
    children: LayoutMeta[];
    /**Metadata that should not be required for building the DOM tree but useful if we want to make further manipulations */
    meta: SharedLayoutFurtherMeta & Partial<{
        /**Whether there is another node in front of the node being tested */
        isBlocked: boolean;
        /**Used to indicate the name of the prop used for a particular instance swap node*/
        instanceName: string;
        groupingProps: {
            [propKey: string]: string;
        };
        /**Used for selecting multiple screens for merging and if we want to do further nesting */
        groupingTemplate: LayoutElementMeta | undefined;
        /** Used for suggesting that an element should use a ui library */
        suggestedTag: SuggestedTagMeta;
        childComponentId: string;
        controllableClasses: string[];
        props: ComponentMeta['props'];
        componentProperties: CustomSceneNode['componentProperties'];
        numTextLines: number;
        possibleMatch: PossibleMatch;
        fjUserComponentSize: {
            height: number;
            width: number;
        };
        effectiveHtmlTag: LayoutElementMeta['semanticTag'];
        reshapedMeta: {
            componentName?: string;
            nestedComponent?: {
                name: string;
                attrs: LayoutElementMeta['attrs'];
            };
        };
    }> & Record<string, unknown>;
}
export type SuggestedTagMetaFor<K> = Extract<SuggestedTagMeta, {
    tag: K;
}>;
export type SuggestedTagMeta = {
    tag: 'a';
    linkType: 'url' | 'component';
    link: string;
} | {
    tag: 'button';
    type?: string;
} | {
    tag: 'input';
    type: string;
    name: string;
    id?: string;
    placeholderNameCml?: string;
} | {
    tag: 'menu';
    options: LayoutMeta[];
} | {
    tag: 'select';
    name: string;
    id?: string;
    options: LayoutMeta[];
} | {
    tag: 'label';
    id: string;
};
export interface LayoutNested {
    styles: LayoutStyles;
}
export interface LayoutNestedFull extends LayoutNested {
    atRuleName: string;
}
export interface LayoutPseudoElement {
    styles: LayoutStyles;
}
export interface LayoutPseudoElementFull extends LayoutPseudoElement {
    pseudoElement: PseudoSelector;
}
export interface ConditionalStyle {
    styles: LayoutStyles;
}
export interface ConditionalStyleFull extends ConditionalStyle {
    condition: TSSourceCode;
}
export interface ConditionalAttr {
    attrs: {
        [nameCml: string]: LayoutAttr;
    };
}
export interface ConditionalClass {
    classes: string[];
}
export interface ConditionalClassFull extends ConditionalClass {
    condition: TSSourceCode;
}
export type EventModifier = 'preventDefault' | 'stopPropagation' | 'capture';
export type LayoutAttr = LayoutAttrNormal | LayoutAttrStyle | LayoutAttrBinding;
export interface LayoutAttrNormal {
    type: 'attr';
    val: LayoutMeta;
}
export interface LayoutAttrBinding {
    type: 'binding';
    modifiers?: EventModifier[];
    usesEventAs?: string;
    val: CodeExpression;
}
export interface LayoutAttrStyle {
    type: 'style';
    styles: LayoutStyles;
}
export interface LayoutAttrStyleFull extends LayoutAttrStyle, NamesMixin {
}
export interface LayoutAttrNormalFull extends LayoutAttrNormal, NamesMixin {
}
export interface LayoutAttrBindingFull extends LayoutAttrBinding, NamesMixin {
}
export type LayoutAttrFull = (LayoutAttrStyleFull | LayoutAttrNormalFull)[];
export interface LayoutStyleFull extends NamesMixin {
    val: CodeExpression;
    valCSS: string;
}
export interface LayoutStaticMeta {
    type: 'static';
    condition?: TSSourceCode;
    val: CodeExpression;
    meta: SharedLayoutFurtherMeta & Partial<{
        styledTextSegment: CustomStyledTextSegment;
    }> & Record<string, unknown>;
}
export interface AllStyles {
    [styleClassName: string]: LayoutStyleFull[];
}
export interface NestedStyles {
    [mediaQuery: string]: {
        [styleClassName: string]: LayoutStyleFull[];
    };
}
export type DependencyMeta = ComponentDependency | ExternalDependency;
export interface ExternalDependency {
    type: 'external';
    defaultImport?: {
        name: string;
        starImport: boolean;
    };
    namedImports: string[];
    path: string;
    /**Version can be undefined if it is external in the in a seperate monorepo package sense */
    version?: string;
}
export interface ComponentDependency {
    type: 'component';
    namePscl: string;
    nameCml: string;
    nameKbb: string;
    path: string;
}
export type GenerateFolder = (meta: CodeMeta) => Folder;
export {};
