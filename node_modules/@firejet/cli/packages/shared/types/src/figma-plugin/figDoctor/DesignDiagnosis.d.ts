import { DesignNode } from './DesignMeta';
import { GptResult } from '../../gpt';
export type DesignDiagnosisInput = {
    checkedDesigns: DesignNode[];
    /**We are passing all nodes into the context so still ok if neighbouring designs are seperate, for now */
    neighbouringDesigns: DesignNode[];
};
type ValueKeysToValueDict<Values extends string[]> = Record<Values[number], string>;
export type DiagnosisResult<Values extends string[] = string[]> = Omit<DesignDiagnosisInput, 'checkedDesigns'> & {
    checkedDesign: DesignNode;
    values: ValueKeysToValueDict<Values>;
};
export type DesignProblemTemplate<Values extends string[] = string[]> = {
    llmInstructions: string;
    values: Values;
};
export declare const PROBLEM_TEMPLATES: {
    readonly missingBackButton: {
        readonly action: "MISSING_BACK_BUTTON";
        readonly values: ["mainFrameId"];
        readonly description: "A list of nodes that are missing a back button.";
        readonly display: {
            readonly name: "Missing Back Button";
            readonly entry: () => undefined;
        };
    };
    readonly missingLinkedScreen: {
        readonly action: "MISSING_LINKED_SCREEN";
        readonly values: ["mainFrameId", "linkId", "missingScreenName"];
        readonly description: "A list of links that are missing a linked screen.";
        readonly display: {
            readonly name: "Missing Linked Screen";
            readonly entry: ({ linkId, missingScreenName }: Record<string, string>) => string;
        };
    };
};
export type DiagnosisFull = GptResult<typeof PROBLEM_TEMPLATES>;
export {};
