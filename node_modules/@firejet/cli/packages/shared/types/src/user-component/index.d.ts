import { GradientNode } from 'gradient-parser';
import { CustomSceneNode, LayoutElementMeta } from '../figma-plugin';
import { Rectangle } from '../posMeta';
import { HtmlToFigmaSuccess, MinNode } from '../html-to-figma';
import { Database } from '../supabase-types';
import { MergeWithReplace } from '../util/replace';
import { MinLayout } from './minLayout';
import { ComponentDef } from '../cli/firejetCLIconfig';
import { PropPath, SerializedPropPath } from './domFlags';
export * from './minLayout';
export * from './domFlags';
export interface UngroupedCompoNode {
    id: number;
    children: UngroupedCompoNode[];
    boundingBox: Rectangle;
    codeMetaSubTreePath: number[];
}
export interface GroupedCompoElement extends Omit<UngroupedCompoNode, 'children'> {
    type: 'el';
    child?: GroupedCompoNodeLayout;
}
export type GroupedCompoNodeLayout = GroupedCompoElement | ColGrouping<GroupedCompoNodeLayout> | RowGrouping<GroupedCompoNodeLayout> | StackGrouping<GroupedCompoNodeLayout>;
export interface MappedNonTextElement extends Omit<UngroupedCompoNode, 'children'> {
    type: 'non-text';
    styles: Styles;
    controllableClass?: string;
    child?: MappedCompoNodeLayout;
}
export interface MappedTextElement extends Omit<UngroupedCompoNode, 'children'> {
    type: 'text';
    styles: Styles;
    text: RichText[];
}
export interface MappedComponentElement extends Omit<UngroupedCompoNode, 'children'> {
    type: 'child-component';
    componentId: string;
}
export type MappedCompoNodeLayout = MappedTextElement | MappedNonTextElement | MappedComponentElement | ColGrouping<MappedCompoNodeLayout> | RowGrouping<MappedCompoNodeLayout> | StackGrouping<MappedCompoNodeLayout>;
export interface StackGrouping<T> {
    type: 'stack';
    group: T[];
    boundingBox: Rectangle;
}
export interface ColGrouping<T> {
    type: 'col';
    group: T[];
    boundingBox: Rectangle;
}
export interface RowGrouping<T> {
    type: 'row';
    group: T[];
    boundingBox: Rectangle;
}
export type RGBA = [number, number, number, number];
export interface Border {
    left: BorderComponent;
    right: BorderComponent;
    top: BorderComponent;
    bottom: BorderComponent;
}
export interface BorderComponent {
    width: number;
    style: 'dotted' | 'dashed' | 'solid' | 'double' | 'groove' | 'ridge' | 'inset' | 'outset';
    color: RGBA;
}
export declare const DEFAULT_NON_TEXT_STYLES: {
    opacity: number;
};
export declare const DEFAULT_TEXT_STYLES: {
    textColor: number[];
    fontWeight: number;
    opacity: number;
};
export type CornerRadius = {
    max: number;
} | number;
export interface BorderRadius {
    topLeft: CornerRadius;
    topRight: CornerRadius;
    bottomLeft: CornerRadius;
    bottomRight: CornerRadius;
}
export type GradientFill = GradientNode & {
    original: string;
};
export type UrlFill = {
    url: string;
} & {
    original: string;
};
export interface Styles {
    opacity?: number;
    border?: Border;
    borderRadius?: BorderRadius;
    background?: RGBA | UrlFill | GradientFill;
    textColor?: RGBA | UrlFill | GradientFill;
    fontFamily?: string;
    fontWeight?: number;
    textDecoration?: {
        line: 'underline' | 'strikethrough' | 'overline';
        style: 'solid' | 'double' | 'dotted' | 'dashed' | 'wavy';
        color: RGBA;
        thickness: number;
    };
    textTransform?: 'uppercase' | 'lowercase' | 'full-width' | 'small-caps';
    lineHeight?: number;
    letterSpacing?: number;
    textAlign?: 'left' | 'right' | 'start' | 'end' | 'center' | 'justify';
    textOverflow?: 'clip' | 'ellipsis';
    verticalAlign?: 'top' | 'middle' | 'bottom' | 'sub' | 'super';
}
export type InheritableTextStyles = Omit<Styles, 'opacity' | 'border' | 'borderRadius' | 'background'>;
export interface RichText extends Styles {
    characters: string;
    controllableClass?: string;
}
export type ConditionalProp = {
    pathToProp: PropPath;
    possibleVals: PropVal[];
};
type PropVal = boolean | string;
export type PropCombination = Record<SerializedPropPath, PropVal>;
export interface MappedWebsiteComponent {
    websiteUrl: string;
    componentName: string;
    img: string;
    figmaNodes: HtmlToFigmaSuccess;
    screenWidth: number;
    theme: 'light' | 'dark';
}
export interface MappedUserComponent {
    componentId: string;
    componentName: string;
    componentFile: string;
    defaultExport: boolean;
    conditionals?: PropCombination;
    img: string;
    code: string;
    /** The group that the component is from - good if components clash between groups, like MUI button and shadcn button
     * Can be null for reference designs
     */
    groupId: string | null;
    figmaNodes: HtmlToFigmaSuccess;
    componentDef: ComponentDef | undefined;
}
interface UserComponentBase {
    code_meta_tree: LayoutElementMeta;
    conditionals?: PropCombination;
    object_tree: MinLayout;
    original_scene_node: CustomSceneNode;
    fixed_scene_node: CustomSceneNode;
    min_node: MinNode;
    component_def: ComponentDef;
    group_name: string;
    enterprise_team_id: string;
}
export type UserComponent = MergeWithReplace<Database['public']['Tables']['user_components']['Row'], UserComponentBase>;
export type UserComponentExtended = {
    type: 'WEBSITE' | 'COMPONENT' | 'COMPONENT_SET';
    /**For website and component, returns a single item */
    componentSet: UserComponent[];
};
interface WebsiteComponentBase {
    component_name: string;
    min_node: MinNode;
}
export type WebsiteComponentExtended = {
    type: 'WEBSITE' | 'COMPONENT';
    componentSet: WebsiteComponentBase[];
};
export type UserComponentWithImage = Omit<UserComponent, 'img'> & {
    img: Buffer;
};
export type UserCompiledCodebaseGroups = Database['public']['Tables']['user_compiled_codebase']['Row'];
export interface DetectObjectsResult {
    objects: DetectedObjects;
}
export interface DetectedObjects {
    compos: Compo[];
    imgShape: {
        width: number;
        height: number;
    };
}
export interface ImageShape {
    width: number;
    height: number;
}
export interface Compo {
    id: number;
    /**
     * Block - A rectangle that can contain children
     * Compo - Images or SVGs, that should not contain children
     * Text - Text
     */
    class: 'Block' | 'Text' | 'Compo';
    rect: Rectangle;
    children?: number[];
    parent?: number;
}
