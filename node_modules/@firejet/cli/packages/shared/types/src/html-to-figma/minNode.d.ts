import { FJ } from '../cli';
import { CustomSceneNode, CustomStyledTextSegment } from '../figma-plugin';
/**
 * We define 'min' types such that we have minimal work to define a fully functional figma design.
 * No stars, lines, boolean or any other bullshit.
 */
export type MinDimensionAndPositionMixin = Pick<CustomSceneNode, 'x' | 'y' | 'width' | 'height' | 'absoluteBoundingBox' | 'absoluteRenderBounds' | 'constraints'>;
/**Used for defining meta that needs to be passed from minNode to sceneNode to layoutMeta to minLayout */
export type MinSharedMeta = MinLayoutGroupMeta & {
    /**Props linked to the particular element that are populated when the running html to minnode*/
    fjSyncProps?: NonNullable<FJ.PropsWithoutImplementation>;
};
export type MinLayoutGroupMeta = {
    /**Whether a node can be repeated multiple times during matching. Comes with an ID to identify the group */
    repeatId?: {
        /**The id of the struct being repeated */
        structId: number;
        /**The nth time it is repeated - for detection we don't need any other than the first */
        groupId: number;
    };
    /**For a particular structId, only specific groupIds are allowed */
    eitherId?: {
        structId: number;
        /**This will be undefined on the 'either' node, and only defined when reaching the 'either-option' node */
        groupId: number | undefined;
    };
    /**Whether a node is optional during matching. Comes with an ID to identify the group */
    optionalId?: number;
};
export type MinLayoutGroupKey = keyof MinLayoutGroupMeta;
/**Additional metadata purely for passing props through the pipeline so we have the data to use during the matching
 * Basically for passing meta from sceneNode to layoutMeta (but excluding minNode)
 */
export type MinMetaMixin = {
    meta: {
        minSharedMeta: MinSharedMeta;
        nodeHasEffectOnDesign: boolean;
    };
};
export type MinNameMixin = {
    name: string;
};
/**Must include blendmode for accurate conversion! */
export type MinFillsMixin = Pick<CustomSceneNode, 'fills'>;
export type MinMaskMixin = Pick<CustomSceneNode, 'isMask'>;
export type MinTextSegment = Pick<CustomStyledTextSegment, 'characters' | 'lineHeight' | 'fontSize' | 'fontWeight' | 'fontName' | 'letterSpacing' | 'textCase' | 'textDecoration' | 'hyperlink' | 'fills' | 'listOptions'>;
export type MinStyledTextSegmentMixin = {
    styledTextSegments: MinTextSegment[];
} & Pick<CustomSceneNode, 
/**We handle this here because its easier to compute together with the mintextsegments */
'paragraphIndent' | 'layoutSizingHorizontal'>;
export type MinTextBaseMixin = Pick<CustomSceneNode, 'textAlignHorizontal' | 'paragraphSpacing'>;
export type MinTextMixin = MinTextBaseMixin & MinStyledTextSegmentMixin;
export type MinChildrenMixin = {
    children?: MinNode[];
};
export type MinStrokeMixin = Pick<CustomSceneNode, 'strokes' | 'strokeBottomWeight' | 'strokeLeftWeight' | 'strokeTopWeight' | 'strokeRightWeight'>;
export type MinBorderRadiusMixin = Pick<CustomSceneNode, 'topLeftRadius' | 'topRightRadius' | 'bottomLeftRadius' | 'bottomRightRadius'>;
export type MinEffectMixin = Pick<CustomSceneNode, 'effects'>;
export type MinClipsContentMixin = Pick<CustomSceneNode, 'clipsContent'>;
export type MinOpacityMixin = Pick<CustomSceneNode, 'opacity'>;
export type MinSVGMixin = {
    isVector: true;
    svgPath: string;
};
export type MinBlendModeMixin = Pick<CustomSceneNode, 'blendMode'>;
export type MinTransformMixin = Pick<CustomSceneNode, 'relativeTransform'>;
export type MinBaseMixin = MinDimensionAndPositionMixin & MinMetaMixin & MinOpacityMixin;
export type MinFrameMixin = MinStrokeMixin & MinBorderRadiusMixin & MinEffectMixin & MinClipsContentMixin & MinMaskMixin;
export interface MinFrameNode extends MinBaseMixin, MinFillsMixin, MinFrameMixin, MinNameMixin, MinTransformMixin, MinChildrenMixin {
    type: 'FRAME';
}
export interface MinTextNode extends MinBaseMixin, MinTextMixin, MinNameMixin {
    type: 'TEXT';
}
export interface MinSVGNode extends MinBaseMixin, MinSVGMixin, MinNameMixin, MinBlendModeMixin, MinTransformMixin {
    type: 'VECTOR';
}
export type MinNode = MinFrameNode | MinTextNode | MinSVGNode;
export type FontMeta = {
    familyName: string;
    fullName: string;
    postscriptName: string;
    subfamilyName: string;
    copyright: string;
    version: string;
    url: string;
};
export type FontFamilyMeta = Record<string, FontMeta[]>;
export type HtmlToFigmaSuccess = {
    minNodes: MinNode[];
};
export type HtmlToFigmaError = {
    error: Error | unknown;
};
export type HtmlToFigmaResult = HtmlToFigmaSuccess | HtmlToFigmaError;
