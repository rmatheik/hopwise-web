import { BaseSupportedStyles, LayoutElementMeta, LayoutMeta, LayoutStyles, PseudoSelector, StyleKey, TSSourceCode } from '@firejet-sync/shared/types';
declare const COMBINABLE_STYLE_KEYS: readonly ["boxShadow", "backdropFilter", "filter", "left", "right", "top", "bottom", "transform"];
export declare const WRAPPER_ATTR_KEYS_SET: Set<string>;
export declare const MAIN_ELEMENT_ATTR_KEYS_SET: Set<string>;
export type CombinableStyleKey = (typeof COMBINABLE_STYLE_KEYS)[number];
type CombinableStyles = Partial<{
    [K in CombinableStyleKey]: BaseSupportedStyles[K][];
}>;
export declare class UpdateLayoutMeta {
    semanticTag: string;
    removed: boolean;
    /**Whether to make a fake additional parent div, which is needed for things like overflow clip */
    hasParentWrapper: boolean;
    readonly attrs: LayoutElementMeta['attrs'];
    readonly styles: LayoutElementMeta['styles'];
    readonly pseudoElementStyles: LayoutElementMeta['pseudoElementStyles'];
    /**The first child is below all existing children and is the bottommost child of the stack */
    readonly wrapperChildren: LayoutElementMeta['children'];
    /**The first child is before all existing children and is the bottommost child of the stack */
    readonly mainChildren: LayoutElementMeta['children'];
    readonly combinableStyles: CombinableStyles;
    readonly pseudoElementCombinableStyles: Partial<Record<keyof LayoutElementMeta['pseudoElementStyles'], CombinableStyles>>;
    readonly conditionalStyles: LayoutElementMeta['conditionalStyles'];
    readonly meta: LayoutElementMeta['meta'];
    constructor(semanticTag?: string);
    remove(): void;
    addParentWrapper(): void;
    /**Prop Key should be camelcase */
    _addStyle<K extends StyleKey>(styles: LayoutElementMeta['styles'], propKey: K, propVal: LayoutStyles[K], allowCombinableStyle: boolean): void;
    /**Prop Key should be camelcase */
    addStyle<K extends StyleKey>(propKey: K, propVal: LayoutStyles[K], allowCombinableStyle?: boolean): void;
    addMeta<MetaKey extends keyof LayoutElementMeta['meta']>(key: MetaKey, val: LayoutElementMeta['meta'][MetaKey]): void;
    /**Prop Key should be camelcase */
    addPseudoElementStyle<K extends StyleKey>(pseudoElement: PseudoSelector, propKey: K, propVal: LayoutStyles[K], allowCombinableStyle?: boolean): void;
    addConditionalStyle<K extends StyleKey>(condition: TSSourceCode, propKey: K, propVal: LayoutStyles[K]): void;
    addCombinedStyle<K extends CombinableStyleKey>(propKey: K, propVal: BaseSupportedStyles[K]): void;
    addPseudoElementCombinedStyle<K extends CombinableStyleKey>(pseudoElement: PseudoSelector, propKey: K, propVal: BaseSupportedStyles[K]): void;
    /**Attr Name should be camelcase */
    addAttr(attrName: string, val: LayoutMeta): void;
    /**Operates on the WRAPPER ELEMENT
     * Adding does the following:
     * 2. Each new child is the backmost (bottommost) child
     * 3. If there is a wrapper parent the styles will be on the parent
     */
    addWrapperChild(child: LayoutMeta): void;
    /**Operates on the MAIN ELEMENT
     * Adding does the following:
     * 1. Adds the child below existing children
     * 2. Each new child is the backmost (bottommost) child
     */
    addMainChild(child: LayoutMeta): void;
    mergeMainStyles(layout: LayoutElementMeta): void;
    mergeWrapperStyles(layout: LayoutElementMeta): void;
}
export {};
